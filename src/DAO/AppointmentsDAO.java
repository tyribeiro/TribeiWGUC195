package DAO;

import Controller.appointmentSum;
import Helper.DBConnecter;
import Model.CustomersModel;
import Utils.Timezones;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.sql.*;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.spi.LocaleServiceProvider;

import Model.AppointmentsModel;
import javafx.stage.Stage;

import javax.swing.plaf.nimbus.State;
import javax.xml.transform.Result;

public class AppointmentsDAO {

    // database connection
    static Connection connection = DBConnecter.getConnection();


    /**
     * Creates a new appointment in the database.
     *
     * @param appt All the necessary details to add the appointment in the database
     * @return returns true if the appointment is added intro database, returns false if there is an error when adding appointment into the database.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     **/
    public static int addANewAppt(AppointmentsModel appt) throws SQLException{

        int autogeneratedID = -1;
        try {
            //insert new appointment to database
            PreparedStatement ps = connection.prepareStatement(
                    ("INSERT INTO appointments (Title,Description,Location,Contact_ID,Type,Start,End,Customer_ID,User_ID) VALUES (?,?,?,?,?,?,?,?,?)"), PreparedStatement.RETURN_GENERATED_KEYS);

            //converting times to UTC for databse storage
            LocalDateTime utcStart = Timezones.localToUTC(appt.getStart());
            LocalDateTime utcEnd = Timezones.localToUTC(appt.getEnd());

            ps.setString(1,appt.getApptTitle());
            ps.setString(2,appt.getApptDescription());
            ps.setString(3,appt.getApptLocation());
            ps.setInt(4,appt.getContactID());
            ps.setString(5,appt.getApptType());

            ps.setTimestamp(6, Timestamp.valueOf(utcStart));
            ps.setTimestamp(7,Timestamp.valueOf(utcEnd));
            ps.setInt(8,appt.getCustomerID());
            ps.setInt(9,appt.getUserID());

            ps.execute();

            //autogenerated IDs from database
            ResultSet generatedKeys = ps.getGeneratedKeys();
            if(generatedKeys.next()){
                autogeneratedID = generatedKeys.getInt(1);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return autogeneratedID;
    }

    /**
     * This method updates the details of an existing appointment
     * in the database with the details passed as parameters.
     * @param id
     * @param title
     * @param desc
     * @param location
     * @param contactID
     * @param type
     * @param startDate
     * @param endDate
     * @param startTime
     * @param endTime
     * @param customerID
     * @param userID
     * @return returns true if appointment was updated, and false if there was an error updating appointment.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static boolean updateExistingAppt(int id, String title, String desc, String location, int contactID, String type, LocalDate startDate, LocalDate endDate, LocalTime startTime, LocalTime endTime, int customerID, int userID) throws SQLException {
        PreparedStatement ps = connection.prepareStatement("UPDATE appointments SET Title=?,Description=?,Location=?,Contact_ID=?,Type=?,Start=?,End=?,Customer_ID=?,User_ID=? WHERE Appointment_ID=?");
        ps.setString(1, title);
        ps.setString(2, desc);
        ps.setString(3, location);
        ps.setInt(4, contactID);
        ps.setString(5, type);


        //converts to utc to insert into database
        LocalDateTime utcStart = Timezones.localToUTC(startDate.atTime(startTime));
        LocalDateTime utcEnd = Timezones.localToUTC(endDate.atTime(endTime));

        ps.setTimestamp(6,Timestamp.valueOf(utcStart));
        ps.setTimestamp(7,Timestamp.valueOf(utcEnd));
        ps.setInt(8, customerID);
        ps.setInt(9, userID);
        ps.setInt(10, id);

        try {
            ps.execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return false;
    }


    /**
     * This method deletes an appointment from the database. The appointment to delete is specified by the apptID parameter.
     * @param apptID ID of the appointment that is being deleted.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static void deleteExistingAppt(int apptID) throws SQLException{
        PreparedStatement ps = connection.prepareStatement("DELETE FROM appointments WHERE Appointment_ID=?");
        ps.setInt(1,apptID);
        ps.execute();
    }

    /**
     * This method deletes all appointments from the database based with the customerID passed as a parameter.
     * @param customerID ID of the customer whos appointments need to be deleted.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static void deleteApptByCustomerId(int customerID) throws SQLException {
        PreparedStatement ps = connection.prepareStatement("DELETE FROM appointments WHERE Customer_ID=?");
        ps.setInt(1, customerID);
        ps.executeUpdate();
    }

    /**
     * Reads all appointments in the database.
     * @return a list of all the appointments in the database.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static ObservableList<AppointmentsModel> getAllAppointments() throws SQLException {
        ObservableList<AppointmentsModel> appts = FXCollections.observableArrayList();

        PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments AS appointments INNER JOIN contacts AS contacts ON appointments.Contact_ID=contacts.Contact_ID");

        try {
            ps.execute();
            ResultSet rs = ps.getResultSet();

            while (rs.next()) {
                //convertinf utc times from database into local for the user
                Timestamp utcStart = rs.getTimestamp("Start");
                LocalDateTime localStart = Timezones.utcToLocal(utcStart.toLocalDateTime());

                Timestamp utcEnd = rs.getTimestamp("End");
                LocalDateTime localEnd = Timezones.utcToLocal(utcEnd.toLocalDateTime());

                AppointmentsModel appt = new AppointmentsModel(
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        localStart,
                        localEnd,
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name")
                );
                appt.setApptID(rs.getInt("Appointment_ID"));
                appts.add(appt);
            }

            return appts;
        }catch (SQLException e){
            e.printStackTrace();
            return null;
        }
    }


    /**
     * This method reads all appointments from the database that is within the current week.
     * @return returns a list of appointments in the current week.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static ObservableList<AppointmentsModel> getApptsThisWeek() throws SQLException{
        ObservableList<AppointmentsModel> appts  = FXCollections.observableArrayList();

        // get the current date, start date and end date of the current week (monday-sunday)
        LocalDate currentDate= LocalDate.now();
        LocalDate startWeek = currentDate.with(DayOfWeek.MONDAY);
        LocalDate endWeek = currentDate.with(DayOfWeek.SUNDAY);

        //statement to get appointments within the current week
        PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments AS appointments INNER JOIN contacts as contacts ON appointments.Contact_ID=contacts.Contact_ID WHERE Start BETWEEN ? AND ?");
        ps.setDate(1,Date.valueOf(startWeek));
        ps.setDate(2,Date.valueOf(endWeek));

        try {
            ps.execute();
            ResultSet rs = ps.getResultSet();

            while (rs.next()) {

                //convert utc to local times to display for users
                Timestamp utcStart = rs.getTimestamp("Start");
                LocalDateTime localStart = Timezones.utcToLocal(utcStart.toLocalDateTime());

                Timestamp utcEnd = rs.getTimestamp("End");
                LocalDateTime localEnd = Timezones.utcToLocal(utcEnd.toLocalDateTime());


                AppointmentsModel appt = new AppointmentsModel(
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        localStart,
                        localEnd,
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name")
                );
                appt.setApptID(rs.getInt("Appointment_ID"));

                appts.add(appt);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return appts;
    }

    /**
     * This method reads all appointments from the database that is within the current month.
     * @return returns a list of all appointments within the month.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static ObservableList<AppointmentsModel> getApptThisMonth() throws SQLException{
        ObservableList<AppointmentsModel> appts = FXCollections.observableArrayList();

        //get the current date, month start date and month end date
        LocalDate currentDate = LocalDate.now();
        LocalDate startMonth = currentDate.withDayOfMonth(1);
        LocalDate endMonth = currentDate.withDayOfMonth(currentDate.lengthOfMonth());

        //statement to get appointments within the month
        PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments AS appointments INNER JOIN contacts AS contacts ON appointments.Contact_ID=contacts.Contact_ID WHERE Start BETWEEN ? AND ?");
        ps.setTimestamp(1,Timestamp.valueOf(startMonth.atStartOfDay()));
        ps.setTimestamp(2,Timestamp.valueOf(endMonth.atTime(23,59,59)));

        try {
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {
                //converting utc to local times to display for users
                Timestamp utcStart = rs.getTimestamp("Start");
                LocalDateTime localStart = Timezones.utcToLocal(utcStart.toLocalDateTime());

                Timestamp utcEnd = rs.getTimestamp("End");
                LocalDateTime localEnd = Timezones.utcToLocal(utcEnd.toLocalDateTime());


                AppointmentsModel appt = new AppointmentsModel(
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        localStart,
                        localEnd,
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name")
                );
                appt.setApptID(rs.getInt("Appointment_ID"));

                appts.add(appt);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return appts;

    }

    /**
     * This method lets the user get an appointment object, with all the appointment details, of the appointment with the appointment ID passed as a parameter.
     * @param apptID ID of the appointment that the details are being requested for.
     * @return returns the Appointment Object from the database that has the appointment ID passed as a parameter.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static AppointmentsModel getApptsByID(int apptID) throws SQLException {
        ObservableList<AppointmentsModel> appts = FXCollections.observableArrayList();

        //statement to get all appointments in the database that has the appt ID passed as a parameter
        PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments AS appointments INNER JOIN contacts AS contacts ON appointments.Contact_ID=contacts.Contact_ID WHERE appointments.Appointment_ID = ?");
        ps.setInt(1, apptID);

        try {
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {

                //convertin utc to local times to display for users
                Timestamp utcStart = rs.getTimestamp("Start");
                LocalDateTime localStart = Timezones.utcToLocal(utcStart.toLocalDateTime());

                Timestamp utcEnd = rs.getTimestamp("End");
                LocalDateTime localEnd = Timezones.utcToLocal(utcEnd.toLocalDateTime());


                AppointmentsModel appt = new AppointmentsModel(
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        localStart,
                        localEnd,
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name")
                );

                appt.setApptID(rs.getInt("Appointment_ID"));
                appts.add(appt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return appts.get(0);
    }

    /**
     * This method reads all appointments from the database and groups it by contact name.
     * @return returns a map where the key is contact's name, and value is a string with all the appointment information.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static Map<String, String> getApptsByContact() throws SQLException {
        Map<String, String> schedules = new HashMap<>();
        PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments AS appointments INNER JOIN contacts AS contacts ON appointments.Contact_ID=contacts.Contact_ID ORDER BY contacts.Contact_Name, appointments.Start");

        try {
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {

                //converting utc to local times to display for the user
                Timestamp utcStart = rs.getTimestamp("Start");
                LocalDateTime localStart = Timezones.utcToLocal(utcStart.toLocalDateTime());

                Timestamp utcEnd = rs.getTimestamp("End");
                LocalDateTime localEnd = Timezones.utcToLocal(utcEnd.toLocalDateTime());


                String contact = rs.getString("Contact_Name");
                int contactID = rs.getInt("Contact_ID");
                int apptID = rs.getInt("Appointment_ID");
                String apptTitle = rs.getString("Title");
                String apptType = rs.getString("Type");
                String description = rs.getString("Description");
                LocalDate startDate = rs.getTimestamp("Start").toLocalDateTime().toLocalDate();
                LocalDate endDate = rs.getTimestamp("End").toLocalDateTime().toLocalDate();
                LocalTime startTime = rs.getTimestamp("Start").toLocalDateTime().toLocalTime();
                LocalTime endTime = rs.getTimestamp("End").toLocalDateTime().toLocalTime();
                int customerID = rs.getInt("Customer_ID");

                String report = ("\n" + "Contact ID: " + contactID + "/nAppt ID: " + apptID + "/nAppointment Title: " + apptTitle
                        + "/nAppointment Type: " + apptType + "/nDescription: " + description
                        + "/nStart Date and Time: " + startDate + " " + startTime
                        + "/nEnd Date and Time: " + endDate + " " + endTime
                        + "/nCustomer ID: " + customerID);

                if (schedules.containsKey(contact)) {
                    schedules.put(contact, schedules.get(contact) + report);
                } else {
                    schedules.put(contact, report);
                }
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        return schedules;
    }

    /**
     * This method returns a list of appointments that has the Contact Name passed as a parameter.
     * @param contactName the name of the contact in which to read all appointments for.
     * @return a list of appointments from the database that have the contact name provided.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static ObservableList<AppointmentsModel> getApptsByContactName(String contactName) throws SQLException {
        ObservableList<AppointmentsModel> appts = FXCollections.observableArrayList();

        //statement to get all the appointments from the database with the contact name passed as the parameter
        try {
            PreparedStatement ps = connection.prepareStatement("SELECT * FROM appointments as appointments JOIN contacts as contacts ON appointments.Contact_ID = contacts.Contact_ID WHERE contacts.Contact_Name =?");
            ps.setString(1, contactName);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {
                appts.add(new AppointmentsModel(
                        rs.getInt("Appointment_ID"),
                        rs.getString("Title"),
                        rs.getString("Description"),
                        rs.getString("Location"),
                        rs.getString("Type"),
                        rs.getTimestamp("Start").toLocalDateTime(),
                        rs.getTimestamp("End").toLocalDateTime(),
                        rs.getInt("Customer_ID"),
                        rs.getInt("User_ID"),
                        rs.getInt("Contact_ID"),
                        rs.getString("Contact_Name")
                ));
            }
        } catch (Exception e) {
            e.getMessage();
        }
        return appts;
    }


    /**
     * This method looks for any appointments that have overlapping appointment times and adds it to the variable  overlaping.
     * @param appt the appointment that is being checked against all the other appointments in the database for overlapping appointments.
     * @return true if there are overlapping appointment times, and false if no overlapping appointments are found.
     * @throws SQLException if there is an error in accessing database or there is an error in the sql statement.
     */
    public static boolean overlappingAppts(AppointmentsModel appt) throws  SQLException {
        // count is used to find overlapping appointments and return the number of overlapping appointments in that variable
        PreparedStatement ps = connection.prepareStatement("SELECT COUNT(*) as overlapping FROM appointments WHERE ((Start <= ? AND End >= ?) OR (Start <= ? AND End >= ?) OR (Start >= ? AND End <= ?)) AND (Appointment_ID <> ? OR ? = null)");

        //convertin local times to utc to check against all appointment times in the database
        LocalDateTime utcStart = Timezones.localToUTC(appt.getStart());
        LocalDateTime utcEnd = Timezones.localToUTC(appt.getEnd());

        ps.setTimestamp(1,Timestamp.valueOf(utcStart));
        ps.setTimestamp(2,Timestamp.valueOf(utcEnd));
        ps.setTimestamp(3,Timestamp.valueOf(utcStart));
        ps.setTimestamp(4,Timestamp.valueOf(utcEnd));
        ps.setTimestamp(5, Timestamp.valueOf(utcStart));
        ps.setTimestamp(6, Timestamp.valueOf(utcEnd));
        ps.setInt(7, appt.getApptID());
        ps.setInt(8, appt.getApptID());

        ResultSet rs = ps.executeQuery();
        if (rs.next()) {
            //if there are overlapping appointments, it returns true, if not, returns false
            return rs.getInt("overlapping") > 0;
        }
        return false;
    }


    /**
     * This method gets the number of appointments for each customer ID in the database.
     * @return returns a string with the report for the number of appointments for each customer ID.
     */
    public static String getTotalApptsByCustomer() {
        String report = "";
        try {
            PreparedStatement ps = connection.prepareStatement("SELECT Customer_ID, COUNT(*) as count FROM appointments GROUP BY Customer_ID");
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                report = report + rs.getInt("Customer_ID") + ": " + rs.getInt("count") + "\n";
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return report;
    }
}